#! /usr/bin/env node

const axios = require("axios");
const cheerio = require("cheerio");
const fs = require("fs");

const BASE_URL = "https://minecraft.gamepedia.com";

const INTERFACE_DEST = __dirname + "/Command.d.ts";

const INTERFACE_COMMENT =
	"/**" + "\n" +
	" * Minecraft Command Interface" + "\n" +
	" * This file is auto-generated by scraping `https://minecraft.gamepedia.com/Commands` and provides overloads for all Java Edition commands." + "\n" +
	" *" + "\n" +
	" * Please raise an issue at `https://github.com/telecraft/typed-commands/issues` if there are any compilation errors in this file." + "\n" +
	" */" + "\n";

const isRequired = str => new RegExp(/\<[a-zA-Z]+\>/g).test(str);
const isOptional = str => new RegExp(/\[[a-zA-Z]+\]/g).test(str);
const isConstant = str => !isOptional(str) && !isRequired(str);

const cleanupString = str => str.replace(/[\<\[\>\]\(\)]/g, "");

const concatOptions =
	options =>
		options
			.reduce(
				(o, el, i) => o.concat(` "${cleanupString(el)}"${((i !== (options.length - 1)) ? " | " : "")}`), ""
			);

const Writer = path => {
	const writer = fs.createWriteStream(path);

	writer.write(INTERFACE_COMMENT);

	writer.write("interface Command {\n");

	writer.on("done", () => {
		writer.write("}\n");
		writer.close();
	});

	return {
		write: (command, shape) => {
			let overload = `\t(command: "${command}"`;
			const keywords = shape.split(" ");
			let optionsIdx = 0;
			let optionalArgAdded = false;
			const seenConstants = new Map();
			for (let i = 1; i < keywords.length; i++) {
				const key = keywords[i];
				if (key) {
					if (key.startsWith("(") && key.endsWith(")")) {
						const options = key.split("|");
						overload += (`, options${optionsIdx > 0 ? optionsIdx : ''}${optionalArgAdded ? '?' : ''}: ` + concatOptions(options));
						++optionsIdx;
						optionalArgAdded = true;
					} else if (key.startsWith("[")
						&& key.endsWith("]")
						&& key.includes("|")) {
						const options = key.split("|");
						overload += (`, options${optionsIdx > 0 ? optionsIdx : ''}?: ` + concatOptions(options));
						++optionsIdx;
						optionalArgAdded = true;
					} else if (key.startsWith("(")) {
						const options = (key + keywords[i + 1]).split("|");
						overload += (`, options${optionsIdx > 0 ? optionsIdx : ''}${optionalArgAdded ? '?' : ''}: ` + concatOptions(options));
						++optionsIdx;
						++i;
						optionalArgAdded = true;
					} else if (isConstant(key)) {
						const str = cleanupString(key);
						if (str === "function") {
							overload += `, fn${optionalArgAdded ? '?' : ''}: "${str}"`;
						} else {
							if (seenConstants.has(str)) {
								overload += `, ${str}${seenConstants.get(str) ? seenConstants.get(str) : ''}${optionalArgAdded ? '?' : ''}: "${str}"`;
							} else {
								overload += `, ${str}${optionalArgAdded ? '?' : ''}: "${str}"`;
							}
						}
						if (seenConstants.has(str)) {
							seenConstants.set(str, seenConstants.get(str) + 1);
						} else {
							seenConstants.set(str, 1);
						}
					} else if (isRequired(key)) {
						const str = cleanupString(key);
						if (str === "function") {
							overload += `, fnName${optionalArgAdded ? '?' : ''}: "string"`;
						} else if (str === "command") {
							overload += `, commandName${optionalArgAdded ? '?' : ''}: "string"`;
						} else {
							if (seenConstants.has(str)) {
								overload += `, ${str}Name${optionalArgAdded ? '?' : ''}: "string"`;
							} else {
								overload += `, ${str}${optionalArgAdded ? '?' : ''}: "string"`;
							}
						}
					} else if (isOptional(key)) {
						const str = cleanupString(key);
						overload += `, ${str}?: "string"`;
						optionalArgAdded = true;
					}
				}
			}

			overload += "): void;\n";

			writer.write(overload);
		},
		close: () => writer.emit("done")
	};
};

const getJavaEditionCommands = async () => {
	const { data } = await axios.get(BASE_URL + "/Commands");

	const $ = cheerio.load(data);

	const COMMAND_COLUMN = 1;
	const JE_FLAG_COLUMN = 5;

	const commands = [];

	for (let row = 2; row <= $('table.sortable.wikitable tr').length; row++) {
		const el = $(`table.sortable.wikitable tr:nth-child(${row}) td:nth-child(${COMMAND_COLUMN}) > code > a`);
		const command = el.text();
		if (command === '') continue;
		const url = el[0].attribs.href;
		const text = $(`table.sortable.wikitable tr:nth-child(${row}) td:nth-child(${JE_FLAG_COLUMN})`).text();
		if (text.includes('Yes')) commands.push({ command, url });
	}

	return commands;
};



const getCommandShapes = async (command, url) => {
	const searchCommandSyntax = command => {
		if (command === "fill"
			|| command === "setworldspawn"
			|| command === "spawnpoint"
			|| command === "stopsound") {
			const html = $("#Syntax").parent().nextAll("dl:nth-of-type(1)").html();
			const $2 = cheerio.load(html);
			return $2("dd").first().text().replace(/\([a-zA-Z\s]+\)/g, '');
		} else if (command === "worldborder") { // Because gamepedia people are inconsistent and annoying humans whom I wish to give a piece of my mind >.<
			return $("#Syntax").parent().nextAll("ul:nth-of-type(1)").text().replace(/\([a-zA-Z\s]+\)/g, '');
		} else { // Works for most command pages.
			return $("#Syntax").parent().nextAll("dl:nth-of-type(1)").text().replace(/\([a-zA-Z\s]+\)/g, '');
		}
	}

	const { data } = await axios.get(BASE_URL + url);

	const $ = cheerio.load(data);

	const syntax = searchCommandSyntax(command);

	return {
		command,
		overloads: syntax.split("\n")
	};
};

(async function generate() {

	const writer = Writer(INTERFACE_DEST);

	const commands = await getJavaEditionCommands();

	const shapes =
		await Promise
			.all(
				commands
					// .filter(c => c.command === "advancement")
					.map(async ({ command, url }) => await getCommandShapes(command, url))
			);
	shapes
		.forEach(
			shape =>
				shape
					.overloads
					.forEach(o => writer.write(shape.command, o))
		);

	writer.close();

})();
